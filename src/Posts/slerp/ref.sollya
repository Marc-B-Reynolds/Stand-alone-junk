
// This is all very lazy and cut-and-paste
//verbosity=0!;

// generate a slerp impl based on the reference equation
// s(t) = (cos(ta) - d sin(ta)/sin(a)) A + sin(ta)/sin(a) B
//   where d = A.B = cos(a)
//         sin(a) = sqrt(1-a^2)

// slerp{d}_{c}_{s}{d}

// TODO (aka stuff that wasn't pretty much copy-n-paste):
// * zeros aren't rescaled to new range on range reduction/expansion
// * complete error guess code

// ****** CONFIGURATION ******

// the length of the approximation in products
cosP  = 4;    
sinP  = 3;   
atanP = 4;

// which to eliminiate: one or zero of these
elimSin      = true;
elimCos      = false;

hexFloats    = true;         // use hex-floats (otherwise decimal)
atanReduce   = false;        // reduce range of atan input
daSinCos     = false;         // double angle after sin/cos

plotErrorEPS = true;         // emit an eps of t. error
singleP      = true;         // working precision: float or double
maxAngle     = pi/2;         // max angle to support in H (2x for R3)

genCode      = false;        // store gen C into 'name'.h

negDot       = true;         // needs to handle (A.B < 0) cases

approxRsqrt  = true;         //
approxRecip  = true;         //
approxSqrt   = true;         // 

ersqrtd      = "rsqrtd_nr";   // 
ersqrtf      = "fsqrt_nr";    //
erecipd      = "recipd_nr";   // 
erecipf      = "recip_nr";    //

// error to minimize
cosE  = absolute;
sinE  = absolute;
atanE = absolute;

// ****** CONFIGURATION (END) ******

sqrtd        = "sqrt";       // 
sqrtf        = "sqrtf";      //

rsqrtd       = "1.0/sqrt";   // 
rsqrtf       = "1.f/sqrtf";  //
recipd       = "1.0/";       // 
recipf       = "1.f/";       //

execute("util/util.sollya");

if (elimSin == true && elimCos == true) then {
  print("error: can only eliminate one of sin/cos\n");
  quit;
};

listing = "";

display=decimal!;

name = "slerp";
sinN = "" @ sinP;
cosN = "" @ cosP;

if (singleP == true) then {
  name      = name @ "_";
  fsqrt     = sqrtf;
  fabs      = "fabsf";
  fptype    = "float";
  fpsuffix  = "f";
  fpformat  = [|24...|];
  zeroCheat = 2^-24;
  toWP      = "";
  toRP      = "";
  one       = "1.f";
} else {
  name      = name @ "d_";
  fsqrt     = sqrtd;
  fabs      = "fabs";
  fptype    = "double";
  fpsuffix  = "";
  fpformat  = [|53...|];
  zeroCheat = 2^-53;
  toWP      = "(double)";
  toRP      = "(float)";
  one       = "1.0";
};

cosZ = [||];
sinZ = [||];
cosI = 0; // todo for elim 
sinI = 0; // todo for elim

dotMin  = single(cos(maxAngle));
dotMinL = "" @ dotMin;

name = name @ atanP;

// range of atan (TODO: max angle)
if (atanReduce == true) then {
  atanR = [zeroCheat; sqrt(2)-1];
  name  = name @ "r_";
} else {
  atanR = [zeroCheat; 1];
  name  = name @ "_";
};

// ranges of the forward trig approximation(s)
if (daSinCos == true) then {
  cosR  = [0, maxAngle/2];
  sinR  = [zeroCheat, maxAngle/2];
} else {
  cosR  = [0, maxAngle];
  sinR  = [zeroCheat, maxAngle];
};

if (hexFloats == true) then { display=hexadecimal!; };

// ****** atan approximation ******

atanC = [||];
atanL = "";

for i from 1 to 2*atanP by 2 do atanC = atanC:.i;

atanA = fpminimax(atan(x), atanC, fpformat, atanR, floating, atanE);
atanZ = dirtyfindzeros(atan(x)-atanA, atanR);
atanI = dirtyinfnorm(atan(x)-atanA,   atanR);

for i from 2*atanP-1 to 2 by -2 do {
  atanL = "+x2*(" @ coeff(atanA, i) @ fpsuffix @ atanL @ ")";
};

atanL = "    // compute the angle\n" @
        "    " @ fptype @ " x  = y*i;\n" @
        "    " @ fptype @ " x2 = x*x;\n" @
        "    " @ fptype @ " a  = x*(" @ coeff(atanA, 1) @ fpsuffix @ atanL @ ");\n";

atanL = "    // atan setup\n"               @
        "    " @ fptype @ " s2 = " @ one @ "-d*d;\n"  @
        "    " @ fptype @ " i  = recip_nr(" @ one @ "+d);\n" @
        "    " @ fptype @ " rs = rsqrt_nr(s2);\n"    @
        "    " @ fptype @ " y  = s2*rs;\n"           @
        atanL;

// ****** sin approximation ******

if (elimSin == false) then {
  sinL = "";
  sinC = [||];

  for i from 1 to 2*sinP    by 2 do sinC  = sinC:.i;

  sinA = fpminimax(sin(x),  sinC,  fpformat, sinR,  floating, sinE);
  sinZ = dirtyfindzeros(sin(x)-sinA, sinR);
  sinI = dirtyinfnorm(sin(x)-sinA,   sinR);

  for i from 2*sinP-1 to 2 by -2 do {
    sinL = "+a2*(" @ coeff(sinA, i) @ fpsuffix @ sinL @ ")";
  };

  sinL = "ta*(" @ coeff(sinA, 1) @ fpsuffix @ sinL @ ");\n";

} else {
  sinN = "x";
  if (daSinCos == true) then {
    sinL = fsqrt @ "(" @ one @ "-hc*hc);\n";
  } else {
    sinL = fsqrt @ "(" @ one @ "-c*c);\n";
  };
};

if (daSinCos == true) then {
  sinL = "    " @ fptype @ " hs = " @ sinL;
} else {
  sinL = "    " @ fptype @ " s  = " @ sinL;
};

// ****** cos approximation ******

if (elimCos == false) then {
  cosL = "";
  cosC = [||];

  for i from 0 to 2*cosP-1  by 2 do cosC  = cosC:.i;

  cosA = fpminimax(cos(x),  cosC,  fpformat, cosR,  floating, cosE);
  cosZ = dirtyfindzeros(cos(x)-cosA, cosR);
  cosI = dirtyinfnorm(cos(x)-cosA,   cosR);

  for i from 2*cosP-2 to 2 by -2 do {
    cosL = "+a2*(" @ coeff(cosA, i) @ fpsuffix @ cosL @ ")";
  };

  cosL = coeff(cosA, 0) @ fpsuffix @ cosL @ ";\n";

} else {
  cosN = "x";
  if (daSinCos == true) then {
    sinL = fsqrt @ "(" @ one @ "-hs*hs);\n";
  } else {
    sinL = fsqrt @ "(" @ one @ "-s*s);\n";
  };
};

if (daSinCos == true) then {
  cosL = "    " @ fptype @ " hc = " @ cosL;
} else {
  cosL = "    " @ fptype @ " c  = " @ cosL;
};

name = name @ cosN @ "_" @ sinN;

if (daSinCos == true) then {
  name  = name @ "d_";
};

// ****** complete ******

listing = listing @
          "    " @ fptype @ " ta = t*a;\n" @
          "    " @ fptype @ " a2 = ta*ta;\n";

if (elimCos == false) then {
  listing = listing @ cosL @ sinL;
} else {
  listing = listing @ sinL @ cosL;
};

// add sin/cos angle doubling if needed

if (daSinCos == true) then {
  listing = listing @ "    // double angle of sin/cos\n";

  listing = listing @
            "    " @ fptype @ " th = hc+hc;\n" @
            "    " @ fptype @ " c  = th*hc-" @ one @ ";\n" @
            "    " @ fptype @ " s  = th*hs;\n";
};

// listing for explictly loading the components and performing a naive dot product

dotPart = "  " @ fptype @ " ax  = A->x, ay=A->y, az=A->z, aw=A->w;\n" @
          "  " @ fptype @ " bx  = B->x, by=B->y, bz=B->z, bw=B->w;\n";

dotPart = dotPart @ 
          "  " @ fptype @ " d   = ax*bx+ay*by+az*bz+aw*bw;\n";

if (negDot == true) then {
  dotPart = dotPart @
            "  " @ fptype @ " sgn = d >= 0 ? 1 : -1;\n" @
            "  d = " @ fabs @ "(d);\n\n";
};

listing = "void " @ name @
          "(quat_t* R, quat_t* A, quat_t* B, float t)\n{\n" @
	  dotPart @
          "  // d on ~[" @ dotMinL @ ",1]\n"      @
          "  if (d < SLERP_CUT) {\n"              @
          atanL                                   @
          "    // forward trig\n"                 @
          listing                                 @
          "    // weights\n"                      @
          "    " @ fptype @ " s1 = s*rs;\n"       @
          "    " @ fptype @ " s0 = c-d*s1;\n";


if (negDot == true) then {
  listing = listing @ "    s1 *= sgn;\n";
};

listing = listing @
          "  }\n" @
          "  else {\n" @
          "    s0  = "@one@"-t;\n" @
          "    s1  = t;\n";

if (negDot == true) then {
  listing = listing @ "    s1 *= sgn;\n";
};

listing = listing @
          "  }\n  // weight sum\n" @
          "  R->x = " @ toRP @ "(s0*ax + s1*bx);\n" @
          "  R->y = " @ toRP @ "(s0*ay + s1*by);\n" @
          "  R->z = " @ toRP @ "(s0*az + s1*bz);\n" @
          "  R->w = " @ toRP @ "(s0*aw + s1*bw);\n}\n";


//plot(sin(x),0,cos(x),[-Pi,Pi],postscriptfile,"plotSinCos");

//P;
//print("norm   = ", dirtyinfnorm(F-P, R),   "\n");
//print("zeroes = ", dirtyfindzeros(F-P, R), "\n");

//display=decimal!;

//atanZ;
//sinZ;
//cosZ;


print(listing);

//atanZ;
xxx=scale_list_to_f32(atanZ,2);
xxx;
if (genCode == true) then {
  fname = name @ ".h";
  print(listing) > fname;
};

