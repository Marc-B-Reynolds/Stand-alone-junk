// Marc B. Reynolds, 2016
// Public Domain under http://unlicense.org, see link for details.

// This is all very lazy and cut-and-paste

// If it wasn't for VC would be print out the coeff in
// hex-float like this:
//  display=hexadecimal!; 

// type of computation (float is the right answer here)

// error to min: abs seems the better choice

display=decimal!;

// load libraries (hacky)
execute("../../Sollya/util.sollya");
execute("../../Sollya/struct.sollya");
execute("../../Sollya/approx.sollya");

E = absolute;

procedure hack(f,d,r,name)
{
  var p,e,infn,z;
  p    = fpminimax(f, d, [|24...|], r, floating, E);
  e    = f-p;
  infn = dirtyinfnorm(f-p, r);
  z    = list_to_f32(dirtyfindzeros(e, r));
  
  print("// error =", single(infn));
  print("// zero  =",z);
  print("static inline float " @ name @ "(float x) {");
  a_poly_to_source_c(p, "x", "r", 2, true, true)._listing;
  print("  return r;\n}\n");
};

// cheating at bit...can't be bothered to remove the zero
// ulp(1) good enough for me

print("// ******************************");
print("// Generated by atan.sollya");
print("// quick,dirty,hack");

print("// ******************************");
print("// atan on [-1,1]");
min_p = 3;
num   = 6;
R = [2^-24;1];
d = odd_list(min_p);
e = d[min_p-1]+2;

suppressmessage(346);

for i from 1 to num do {
 hack(atan(x), d,R, "atan_" @ (min_p+i));
 d = d :. e; e:=e+2;
};

print("// ******************************");
print("// atan on [-sqrt(2)-1, sqrt(2)-1]");

min_p = 3;
num   = 3;
R= [2^-24; sqrt(2)-1];
d = odd_list(min_p);
e = d[min_p-1]+2;

for i from 1 to num do {
 hack(atan(x), d,R, "atan_h" @ (min_p+i));
 d = d :. e; e:=e+2;
};

