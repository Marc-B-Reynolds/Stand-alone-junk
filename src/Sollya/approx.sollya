// Marc B. Reynolds, 2016
// Public Domain under http://unlicense.org, see link for details.

// approx control structure:
//             1234
//   _name     *... string for pretty printing
//   _nterms   *... target number of product terms
//   _symmetry *... 0=even, 1=odd, 2=neither
//
//   _func     .... function to approximate
//   _range    .... input range (domain)
//   _degree   .... list of values for fpminimax
//   _min_type .... absolute or relative
//   
//   _r_fp32   .... input/ouput in binary32?
//   _w_fp32   .... working in binary32?
//
//   _target_error   ....

// 1) setup code
// 2) fpminimax
// 3) guessdegree

_a_debug = false;
_a_library_loaded = true;

// amount to bias the range in an end-point is a zero.
// massive hack city.
_a_zero_range_bias = 2^-24;

procedure a_debug_print(l)
{
  if (_a_debug == true) then {
     print(l);
  };
};

// f(p)-dx <0 && fp(p)+dx > 0 for all of dom
procedure a_detect_sym_(f,dx,p,dom)
{
  var x0,x1,r;
  r  = false;

  x0 = evaluate(f-dx, p);
  x1 = evaluate(f+dx, p);
  
  if ((x1 > 0) && (x0 < 0)) then {
    var z0,z1;

    z0 = dirtyfindzeros(f-dx, dom);
    z1 = dirtyfindzeros(f+dx, dom);

    if ((z1 == [||]) && (z0 == [||])) then {
      r = true;
   };
  };
  return r;
};

// defines for _symmetry field. Any reason to bother with odd biased?
A_SYMMETRY_EVEN = 0;
A_SYMMETRY_ODD  = 1;
A_SYMMETRY_NONE = 2;


procedure a_detect_symmetry(s)
{
  var dom,f;
  var r;
  var dx;
  var ep;
  
  a_debug_print("a_detect_symmetry");
  r   = A_SYMMETRY_NONE;
  dx  = 2^-24;
  dom = s._range;
  dom = [0; max(abs(sup(dom)), abs(inf(dom)))];
  ep  = sup(dom)/2;

  // even/odd testing functions
  // even: f(x)-f(-x) = 0 -> f(x)/f(-x)-1 = 0
  // odd : f(x)+f(-x) = 0 -> f(x)/f(-x)+1 = 0
  f = simplifysafe(s._func(x)/s._func(-x)-1);

  if (a_detect_sym_(f,ep,dx,dom)) then {
    r = A_SYMMETRY_EVEN;
  } else  {
    f = simplifysafe(s._func(x)/s._func(-x)+1);

    if (a_detect_sym_(f,ep,dx,dom)) then {
      r = A_SYMMETRY_ODD;
    } else {
      print("WARNING: I'm not doing anything reasonable with functions which are neither odd nor even");
    };
  };

  a_debug_print("a_detect_symmetry");
  
  return r;
};

// Guess the needed degree for given error defined
// by field "_target_error".
procedure a_guessdegree(s)
{
  a_debug_print("a_guessdegree");
  r = guessdegree(s._func, s._range, s._target_error);
  s._guessdegree = r;
  a_debug_print("a_guessdegree");
  return r;
};

a_fp_format_f32 = [|24...|];
a_fp_format_f64 = [|53...|];

procedure a_bool_to_fp(is_single)
{
  var r;
  
  if (is_single != false) then {
    r = a_fp_format_f32;
  }
  else {
    r = a_fp_format_f64;
  };
  return r;
};

procedure a_wp(s)
{
  return a_bool_to_fp(s_get_field(s,"_f_fp32",true));
};


procedure a_fpminimax(s)
{
  a_debug_print("a_fpminimax");
  a_debug_print(s);
  suppressmessage(346);
  s._poly    = fpminimax(s._func, s._degree, a_wp(s), s._a_range, floating, s._min_type);
//s._supnorm = supnorm(s._poly, s._func, s._a_range, s._min_type, 2^-128);
  s._infnorm = single(dirtyinfnorm(s._func-s._poly, s._a_range));
  s._zeros   = list_to_f32(dirtyfindzeros(s._func-s._poly, s._a_range));

  a_debug_print("a_fpminimax");
  return s;
};

procedure a_setup(f,r)
{
  var s;
  s._func     = f;           // the function to approx
  s._range    = r;           // input domain of approx
  s._min_type = relative;    // minimize relative error
  s._r_fp32   = true;        // in/out in binary32
  s._w_fp32   = true;        // work in binary32
  return s;
};

procedure a_create_degree(s,n)
{
  var d,t,z,m;

  a_debug_print("a_create_degree");
  t = s._symmetry;

  if (t == A_SYMMETRY_EVEN) then {
    n = ceil((n+1)/2);
    d = even_list(n);
  } else if (t==A_SYMMETRY_ODD) then {
    n = ceil((n+1)/2);
    d = odd_list(n);
  } else {
    d = full_list(n);
  };

  a_debug_print("a_create_degree");

  return d;
};

procedure a_create_nterms(s,n)
{
  var d,t,z,m;

  a_debug_print("a_create_nterms");
  t = s._symmetry;

  if (t == A_SYMMETRY_EVEN) then {
    d = even_list(n);
  } else if (t==A_SYMMETRY_ODD) then {
    d = odd_list(n);
  } else {
    d = full_list(n);
  };

  a_debug_print("a_create_nterms");

  return d;
};


procedure a_narrow_range(s)
{
  var t,r,nr,z;

  a_debug_print("a_narrow_range");
  t  = s._symmetry;
  r  = s._range;
  nr = r;

  if (t != A_SYMMETRY_NONE) then {
    if ((inf(r) <= 0) && (sup(r) >= 0)) then {
      nr = [0,max(-inf(r),sup(r))];
    };
  };

  // see if there are any zeros in the domain
  z = dirtyfindzeros(s._func, nr);

  // MASSIVE DIRTY HACK
  if (z != [||]) then {
    var t;
    t  = nr;
    nr = [||];
    
    if (length(z)==1) then {
      if (within_dx(z[0],inf(t),_a_zero_range_bias)) then {
        nr = [max(inf(t),z[0])+_a_zero_range_bias, sup(t)];
      } else if (within_dx(z[0],sup(t),_a_zero_range_bias)) then {
        nr = [inf(t), min(sup(t),z[0])-_a_zero_range_bias];
      };
    };

    if (nr == [||]) then {
      print("ERROR: I'm too dumb to remove the zeros at: ", z, sup(t), abs(z[0]-sup(t)));
    };
  };

  a_debug_print("a_narrow_range");

  return nr;
};


procedure a_build_approx(s)
{
  var t, refine, success;
  
  a_debug_print("a_build_approx");

  refine  = false;
  success = true;

   // If we don't have an explict list of terms we
  // need to perform some prep work.
  if (s_has_field(s,"_degree") == false) then {
  
    // If we don't know if odd/even/neither...figure it out
    s._symmetry = s_get_field(s, "_symmetry", -1);

    if (s._symmetry < 0 || s._symmetry > A_SYMMETRY_NONE) then
      s._symmetry = a_detect_symmetry(s);

    // Do we have a target theoretic error?
    if (s_has_field(s, "_target_error") == true) then {
      s._guessdegree = a_guessdegree(s);
      s._degree = a_create_degree(s, sup(s._guessdegree));
      refine = true;
    } else if (s_has_field(s, "_nterms") == true) then {
      s._degree = a_create_nterms(s, s._nterms);
    } else {
      success = false;
      print("ERROR: set _target_error and/or _nterms.");
    };
  };

  a_debug_print("a_build_approx: range");

  // work out the actual range to use for the approximation
  if (s_has_field(s,"_a_range") == false) then {
    s._a_range = a_narrow_range(s);
  };

  if (s_has_field(s,"_degree") == true && success == true && s._a_range != [||]) then {
    s = a_fpminimax(s);
  };

  if (success == false) then {
    print("ERROR: could not create approximation.");
  };

  a_debug_print("a_build_approx");
  return s;
};

// returns a copy of 's' with one more product
procedure a_term_add(s)
{
  var S,t;
  S = s_copy(s);

  if (s_has_field(S,"_a_range") != false) then {
    var t,v;
    t = s._degree;
    v = t[length(t)-1];

    if (s._symmetry != A_SYMMETRY_NONE) then {
      t = t :. (v+2);
    } else {
      t = t :. (v+1);
    };
    
    S._degree = t;
    S = a_build_approx(S);
  } else {
    print("ERROR: error in input function.");
  };

  return S;
};

