
// load the library
execute("../util.sollya");
execute("../struct.sollya");
execute("../approx.sollya");

// set up a template structure for full range min abs error
atan_a = a_setup(atan(x), [-1;1]);
atan_a._min_type = absolute;          // default is relative error

atan_h = a_setup(atan(x), [0;1]);
atan_h._min_type = absolute;

_s = proc(x) { single(x); };

// ***********************************************************************
// APPROXIMATIONS FOR DIGITAL COMPUTERS, Hastings, 1955
// sheets 8-13  x on [-1,1] (TODO: wrap contants in single)

atan_ch_8  = x*(0.995354 + x^2*(-0.288679 + 0.079331*x^2));
atan_ch_9  = x*(0.999215 + x^2*(-0.3211819 + x^2*(0.1462766 - 0.0389929*x^2)));
atan_ch_10 = x*(0.999866 + x^2*(-0.3302995 + x^2*(0.180141 + x^2*(-0.085133 + 0.0208351*x^2))));
atan_ch_11 = x*(.99997726 + x^2*(-.33262347 + x^2*(.19354346 + x^2*(-.11643287 + x^2*(.05265332 + -.01172120*x^2)))));
//atan_ch_12 = x*( + x^2*( + x^2*( + x^2*( + x^2*( + *x^2)))));
//atan_ch_13 = x*( + x^2*( + x^2*( + x^2*( + x^2*( + *x^2)))));

a_simple_check_f32("atan_ch_8",   atan(x), [-1;1]);
a_simple_check_f32("atan_ch_9",   atan(x), [-1;1]);
a_simple_check_f32("atan_ch_10",   atan(x), [-1;1]);
a_simple_check_f32("atan_ch_11",   atan(x), [-1;1]);
//a_simple_check_f32("atan_ch_12",   atan(x), [-1;1]);
//a_simple_check_f32("atan_ch_13",   atan(x), [-1;1]);

// all of these are straight polynomial approx on [-1,1] so this simple lib handles
// setting the _nterms field to 3 produces and equivalent to sheet 8.
atan_pa = s_copy(atan_a);           // make a copy
atan_pa._nterms   = 3;              // 3=sheet8,4=sheet9...
atan_pa = a_build_approx(atan_pa);  // make the approx
atan_pa._poly;                      // show polynomial
atan_pa._infnorm;                   // max error
atan_pa._maxpnts;                   // test vector points of max error on _a_range


// ***********************************************************************
// Efficient Approximations for the Arctangent Function, Rajan, Wang, Inkol, Joyal, 2006

atan_rwj_eq5  = single(pi/4)*x+0.285*x*(1-abs(x));
atan_rwj_eq7  = single(pi/4)*x+0.273*x*(1-abs(x));
atan_rwj_eq8  = single(pi/4)*x+x*(0.186982-.191942*x*x);
atan_rwj_eq9  = single(pi/4)*x-x*(abs(x)-1)*(0.2447+.0663*abs(x));
atan_rwj_eq10 = x/(1+.28086*x*x);
atan_rwj_eq11 = x/(1+.28125*x*x);

a_simple_check_f32("atan_rwj_eq5",  atan(x), [-1;1]);
a_simple_check_f32("atan_rwj_eq7",  atan(x), [-1;1]);
a_simple_check_f32("atan_rwj_eq8",  atan(x), [-1;1]);
a_simple_check_f32("atan_rwj_eq9",  atan(x), [-1;1]);
a_simple_check_f32("atan_rwj_eq10", atan(x), [-1;1]);
a_simple_check_f32("atan_rwj_eq11", atan(x), [-1;1]);


atan_rwj = x*(-0.1784 * abs(x) - 0.0663*x*x + 1.0301);
a_simple_check_f32("atan_rwj",      atan(x), [-1;1]);

atan_r = a_setup(x/atan(x), [0;1]);
atan_r._nterms = 2;
atan_r._min_type = absolute;
atan_r0 = a_build_approx(atan_r);

//_a_debug = true;
atan_r1 = s_copy(atan_r);
atan_r1._degree = [|0,2|];
atan_r1;
atan_r1 = a_build_approx(atan_r1);
atan_r1;
quit;


atan_a._nterms   = 4;      
atan_a = a_build_approx(atan_a);
atan_a._poly;
atan_a._infnorm;
atan_a._zeros;
zz = dirtyfindzeros(diff(atan(x)-atan_a._poly(x)), [0;1]);
evaluate(atan(x)-atan_a._poly(x), zz[0]);
evaluate(atan(x)-atan_a._poly(x), zz[1]);

//atan_a._symmetry = A_SYMMETRY_ODD;  // library can deduce


